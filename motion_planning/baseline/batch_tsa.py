# import torch
import time

import numpy as np
import torch

from .search_tree import SearchTree, insert_new_state
# , compute_w, rewire_to, \
# set_cost, update_collision_checks

def batch_RRT_plan(env, dynamics_model, init_state, goal_state, RRT_PARAM, controller=None,
              T=100, g_explore_eps=1., optimal_version=False, stop_when_success=False, model_eps=0.05,
              steer_type='line', batch=50):
    """Robot motion evaluation with NEXT.

    Args:
        env: The environment which stores the problem relevant information (map, 
            initial state, goal state), and performs collision check, goal 
            region check, uniform sampling.
        dynamics_model: Dynamics model of controllable agent in the environment, in neural_cbf/systems
        planning_model: Machine learning gnn_planner used to guide vertex selection and
            tree expansion.
        T (int): Maximum number of samples allowed.
        g_explore_eps (float): Probability for RRT-like global exploration.
        stop_when_success (bool): Whether to terminate the baseline if one path
            is found.
        UCB_type (string): Type of UCB used (one of {'kde', 'GP'}).
        steer_type(str): Type of steer function (one of {'line', 'cbf'}).

    Returns:
        search_tree: Search tree generated by the baseline.
        success (bool): Whether a path is found.
    """
    # no_timer = (timer is None)
    # timer = Timer() if no_timer else timer
    time_dict = {}
    start_time = time.time()
    search_tree = SearchTree(root=init_state)

    success = False
    i = 0
    while i < T:
        leaf_id = None

        # Goal-biased heuristic.
        if np.random.rand() < model_eps:
            sample_states = np.array([goal_state])

        # RRT-like global exploration.
        elif np.random.rand() < g_explore_eps:
            sample_states = None

        # Guided selection and expansion.
        else:
            raise ValueError('g_explore_eps set less than 1, guided expansion not supported at present.')

        for leaf_state, nominal_state, parent_idx, no_collision, done, new_time_dict in global_explore(search_tree, dynamics_model, steer_type=steer_type,
                                                                        sample_states=sample_states, controller=controller, RRT_PARAM=RRT_PARAM, batch=batch):
            i += 1
            success = success or done
            expanded_by_rrt = True

            if optimal_version:
                raise ValueError('Optimal version motion planning not supported.')
                # RRTS_rewire_last(env, search_tree)

            if success and stop_when_success:
                break

            for key in new_time_dict.keys():
                if not key in time_dict:
                    time_dict[key] = new_time_dict[key]
                elif isinstance(time_dict[key], dict):
                    for key2 in new_time_dict[key].keys():
                        time_dict[key][key2] += new_time_dict[key][key2]
                else:
                    time_dict[key] += new_time_dict[key]

        if success and stop_when_success:
            break

        if i % 20 == 0:
            pass

    time_dict['steertime_division'] = {k: v / 1e9 for k, v in time_dict['steertime_division'].items()}
    time_dict['total_time'] = time.time() - start_time
    path = search_tree.path()
    print('total edge: ', i+1)

    return {'success': success,
            'path': path[0],
            'edge_states': path[3],
            'nominal_path': path[2],
            'path_cost': path[1],
            'explored_nodes': i,
            'time_dict': time_dict}


def global_explore(search_tree,
                   dynamics_model,
                   sample_states=None,
                   steer_type='line',
                   controller=None,
                   batch=50,
                   RRT_PARAM=10):
    """One step of RRT-like expansion.

    Args:
        search_tree: Current search tree generated by the baseline.
        dynamics_model: Dynamics model of controllable agent in the environment, in neural_cbf/systems
            and performs collision check, goal region check, uniform sampling.
        sample_state: A randomly sampled state (if provided).
        steer_type(str): Type of steer function (one of {'line', 'cbf'}).

    Returns:
        new_state: New state being added to the search tree.
        sample_state: sampled state before steering.
        parent_idx: Index of the parent of the new state.
        action: Path segment connecting parent and new state.
        no_collision (bool): True <==> the path segment is collision-free.
        done (bool): True <==> the path segment is collision-free and the new
            state is inside the goal region.
        time_list: [total_explore_time, steer_time]
    """
    t_dict = {}
    t0 = time.time()
    non_terminal_states = search_tree.non_terminal_states

    if sample_states is None:
        # Sample uniformly in the maze
        RRT_PARAM = 120
        sample_states = dynamics_model.sample_state_space(batch).numpy()
        # Steer sample to nearby location
        # caculate the distance between sample_state (N x d) and all non_terminal_states (M x d)
        dists = np.linalg.norm(sample_states[:, None, :] - non_terminal_states[None, :, :], axis=-1)
        # dists: N x M
        nearest_idxs, min_dists = np.argmin(dists, axis=1), np.min(dists, axis=1)
    elif non_terminal_states.shape[0] < batch:
        dists = np.linalg.norm(sample_states[:, None, :] - non_terminal_states[None, :, :], axis=-1)
        # dists: N x M
        nearest_idxs, min_dists = np.argmin(dists, axis=1), np.min(dists, axis=1)
    else:
        # calculate nearest n neighbors
        dists = np.linalg.norm(non_terminal_states - sample_states[0], axis=-1)
        nearest_idxs, min_dists = np.argsort(dists, axis=0)[:batch], np.sort(dists, axis=0)[:batch]
        sample_states = np.array([sample_states[0] for _ in range(batch)])

        # use random nearests
    random_nearests = [bool(np.random.rand() > 0.9) for _ in range(min(batch, non_terminal_states.shape[0]))]
    if steer_type == 'cbf':
        for i in range(len(random_nearests)):
            if random_nearests[i]:
                nearest_idxs[i] = np.random.randint(0, non_terminal_states.shape[0])

    t1 = time.time()
    t_dict['explore_1'] = (t1 - t0) / len(sample_states)

    # PARAM by default 10
    assert RRT_PARAM % 20 == 0
    current_states = non_terminal_states[nearest_idxs]
    parent_idxs = nearest_idxs.copy()
    for i in range(RRT_PARAM // 20):
        if steer_type == 'line':
            new_states, no_collisions, steer_time_dict, edge_states_list = steer(dynamics_model.u_nominal, dynamics_model, sample_states, current_states, RRT_step=20, device='cpu')
        elif steer_type == 'cbf':
            assert hasattr(controller, 'u')
            new_states, no_collisions, steer_time_dict, edge_states_list = steer(controller.u, dynamics_model, sample_states, current_states, RRT_step=20, device=controller.device)
        else:
            raise ValueError("Unknown steer_type, must be one of {'line', 'cbf'}.")

        for ii, sample_state, new_state, parent_idx, no_collision, edge_states in zip(range(len(parent_idxs)), sample_states, new_states,
                                                                                   parent_idxs, no_collisions,
                                                                                   edge_states_list):
            leaf_id = insert_new_state(search_tree, new_state, sample_state, edge_states, \
                                   parent_idx, no_collision, bool(dynamics_model.goal_mask(torch.Tensor(new_state).unsqueeze(0)).numpy()))
            parent_idxs[ii] = leaf_id
        current_states = new_states

    t2 = time.time()

    for sample_state, new_state, nearest_idx, no_collision in zip(sample_states, new_states, nearest_idxs, no_collisions):
        # if not no_collision:
        #     print('warning')
        t_dict['steertime_division'] = {k: v for k, v in steer_time_dict.items()}
        t_dict['total_steer'] = (t2 - t1) / len(sample_states)
        done = bool(dynamics_model.goal_mask(torch.Tensor(new_state).unsqueeze(0)).numpy())
        t_dict['total_explore']=(time.time()-t0) / len(sample_states)
        # print(t_dict)
        yield new_state, sample_state, search_tree.non_terminal_idxes[nearest_idx], no_collision, done, t_dict

@torch.no_grad()
def steer(u, dynamics_model, sample_states, nearests, RRT_step=10, device='cpu'):
    # steer time: [V_with_jacobian, Lf_V & Lg_V, QP]
    time_dict = {'complete_sample': 0., 'cl_dynamics': 0.}
    t0 = time.time()
    no_collisions = [True for _ in range(len(sample_states))]
    xs_list = [[] for _ in range(len(sample_states))]
    controller_update_freq = dynamics_model.controller_dt // dynamics_model.dt

    dynamics_model.set_intermediate_goals(sample_states)
    x_current = dynamics_model.complete_sample_with_observations(torch.tensor(nearests, device=device), len(nearests))
    time_dict['complete_sample'] += (time.time() - t0) / len(sample_states)
    for tstep in range(RRT_step):
        if tstep % controller_update_freq == 0:
            u_current = u(x_current)
            if isinstance(u_current, tuple):
                u_current, u_time_dict = u_current
            else:
                u_time_dict = {}
            for key in u_time_dict.keys():
                if not key in time_dict:
                    time_dict[key] = u_time_dict[key] / len(sample_states)
                else:
                    time_dict[key] += u_time_dict[key] / len(sample_states)

        t1 = time.time()
        if (tstep + 1) % controller_update_freq == 0:
            x_current = dynamics_model.closed_loop_dynamics(x_current, u_current, update_observation=True)
        else:
            x_current = dynamics_model.closed_loop_dynamics(x_current, u_current, update_observation=False)
        t2 = time.time()
        time_dict['cl_dynamics'] += (t2 - t1) / len(sample_states)
        for i in range(len(xs_list)):
            stuck = len(xs_list[i]) > 10 and np.linalg.norm(xs_list[i][-1] - xs_list[i][-10]) < 3e-2
            no_collisions[i] = no_collisions[i] and not stuck and not dynamics_model.unsafe_mask(x_current[i].reshape(1, -1))
            if no_collisions[i]:
                xs_list[i].append(x_current[i].cpu().squeeze().numpy())
        if not True in no_collisions:
            break

    return x_current.cpu().numpy()[:, :dynamics_model.q_dims], no_collisions, time_dict, xs_list
