# import torch
import time
from tqdm import tqdm

import numpy as np
import torch

from .search_tree import SearchTree, insert_new_state
# , compute_w, rewire_to, \
# set_cost, update_collision_checks
# from utils.timer import Timer


# def RRTS_plan(env, T=100, stop_when_success=False, timer=None):
#     return NEXT_plan(env=env, T=T, g_explore_eps=1., stop_when_success=stop_when_success, timer=timer)


def RRT_plan(**kwargs):
    return NEXT_plan(**kwargs)


def NEXT_plan(env, dynamics_model, init_state, goal_state, RRT_PARAM, controller=None,
              T=100, g_explore_eps=1., optimal_version=False, stop_when_success=False, model_eps=0.05,
              steer_type='line'):
    """Robot motion evaluation with NEXT.

    Args:
        env: The environment which stores the problem relevant information (map, 
            initial state, goal state), and performs collision check, goal 
            region check, uniform sampling.
        dynamics_model: Dynamics model of controllable agent in the environment, in neural_cbf/systems
        planning_model: Machine learning gnn_planner used to guide vertex selection and
            tree expansion.
        T (int): Maximum number of samples allowed.
        g_explore_eps (float): Probability for RRT-like global exploration.
        stop_when_success (bool): Whether to terminate the baseline if one path
            is found.
        UCB_type (string): Type of UCB used (one of {'kde', 'GP'}).
        steer_type(str): Type of steer function (one of {'line', 'cbf'}).

    Returns:
        search_tree: Search tree generated by the baseline.
        success (bool): Whether a path is found.
    """
    # no_timer = (timer is None)
    # timer = Timer() if no_timer else timer
    time_dict = {}
    start_time = time.time()
    search_tree = SearchTree(root=init_state)

    success_edge = 0

    success = False
    for i in range(T):
        # print('='* 20, "new node", '='*20)
        leaf_id = None

        # Goal-biased heuristic.
        if np.random.rand() < model_eps:
            leaf_state, nominal_state, parent_idx, no_collision, done, new_time_dict, edge_states = global_explore(search_tree, dynamics_model, steer_type=steer_type,
                                                                        sample_state=goal_state, controller=controller, RRT_PARAM=RRT_PARAM)
            success = success or done
            expanded_by_rrt = True

        # RRT-like global exploration.
        elif np.random.rand() < g_explore_eps:
            leaf_state, nominal_state, parent_idx, no_collision, done, new_time_dict, edge_states = global_explore(search_tree, dynamics_model,
                                                                        steer_type=steer_type, controller=controller, RRT_PARAM=120)
            success = success or done
            expanded_by_rrt = True

        # Guided selection and expansion.
        else:
            raise ValueError('g_explore_eps set less than 1, guided expansion not supported at present.')
            # idx = select(search_tree, env, c=c, timer=timer)
            # assert search_tree.freesp[idx]
            # # assert not search_tree.in_goal_region[idx]
            #
            # parent_idx = idx
            # leaf_state, _, no_collision, done = \
            #     expand(search_tree, parent_idx, model, env, c=c, timer=timer)
            # success = success or done
            # expanded_by_rrt = False

        if no_collision:
            success_edge += 1
        # else:
        #     print(f"current cbf on collision state: {controller.h(dynamics_model.complete_sample_with_observations(torch.tensor(leaf_state).unsqueeze(0), 1)).squeeze()}")

        # leaf_id = insert_new_state(search_tree, leaf_state, nominal_state, edge_states, \
        #                            parent_idx, no_collision, done, expanded_by_rrt=expanded_by_rrt)
        if optimal_version:
            raise ValueError('Optimal version motion planning not supported.')
            # RRTS_rewire_last(env, search_tree)

        for key in new_time_dict.keys():
            if not key in time_dict:
                time_dict[key] = new_time_dict[key]
            elif isinstance(time_dict[key], dict):
                for key2 in new_time_dict[key].keys():
                    time_dict[key][key2] += new_time_dict[key][key2]
            else:
                time_dict[key] += new_time_dict[key]
        # print(time_dict)

        # print(leaf_state, success)
        if success and stop_when_success:
            break

        if (i+1)%20==0:
            # print(i)
            pass

    time_dict['total_time'] = time.time() - start_time
    path = search_tree.path()
    print('success edge: ', success_edge, 'total edge: ', i+1, 'success rate: ', success_edge/(i+1))

    return {'success': success,
            'path': path[0],
            'edge_states': path[3],
            'nominal_path': path[2],
            'path_cost': path[1],
            'explored_nodes': i + 1,
            'time_dict': time_dict,
            'success_edge': success_edge,
            'all_vertex': search_tree.states,
            'all_edge': search_tree.x_list,}


def global_explore(search_tree, dynamics_model, sample_state=None, steer_type='line', controller=None,
                   RRT_PARAM=10):
    """One step of RRT-like expansion.

    Args:
        search_tree: Current search tree generated by the baseline.
        dynamics_model: Dynamics model of controllable agent in the environment, in neural_cbf/systems
            and performs collision check, goal region check, uniform sampling.
        sample_state: A randomly sampled state (if provided).
        steer_type(str): Type of steer function (one of {'line', 'cbf'}).

    Returns:
        new_state: New state being added to the search tree.
        sample_state: sampled state before steering.
        parent_idx: Index of the parent of the new state.
        action: Path segment connecting parent and new state.
        no_collision (bool): True <==> the path segment is collision-free.
        done (bool): True <==> the path segment is collision-free and the new 
            state is inside the goal region.
        time_list: [total_explore_time, steer_time]
    """
    t_dict = {}
    t0 = time.time()
    non_terminal_states = search_tree.non_terminal_states

    # Sample uniformly in the maze
    if sample_state is None:
        sample_state = dynamics_model.sample_state_space(1).numpy().squeeze()

    # Steer sample to nearby location
    dists = np.linalg.norm(non_terminal_states - sample_state, axis=-1)
    if True: # steer_type == 'line':
        nearest_idx = np.argmin(dists)
    else:
        if np.random.rand() < 0.9:
            nearest_idx = np.argpartition(dists, min(10, len(dists) - 1))[0]
            # nearest_idx = np.argmin(dists)
        else:
            # nearest_idx = np.argpartition(dists, max(min(len(dists) - 1, 10), len(dists)//2))[0 if len(dists) < 2 else np.random.randint(len(dists)//2)]
            nearest_idx = np.random.randint(len(non_terminal_states))
    t1 = time.time()

    t_dict['explore_1'] = t1-t0
    # PARAM by default 10
    # assert RRT_PARAM %20 == 0
    current_state = non_terminal_states[nearest_idx]
    parent_idx = nearest_idx
    t_dict['steertime_division'] = {'total_steer': 0, 'insert': 0, 'update_dict': 0}
    for _ in range(RRT_PARAM//30):
        ttt0 = time.time()
        if steer_type == 'line':
            new_state, no_collision, steer_time_dict, edge_states = steer(dynamics_model.u_nominal, dynamics_model, sample_state,
                                                             current_state, RRT_step=30, device='cpu')
        elif steer_type == 'cbf':
            assert hasattr(controller, 'u')
            new_state, no_collision, steer_time_dict, edge_states = steer(controller.u, dynamics_model, sample_state,
                                                             current_state, RRT_step=30, device=controller.device)
        else:
            raise ValueError("Unknown steer_type, must be one of {'line', 'cbf'}.")
        # print(new_state)
        ttt1 = time.time()
        leaf_id = insert_new_state(search_tree, new_state, sample_state, edge_states, \
                                   parent_idx, no_collision, bool(dynamics_model.goal_mask(torch.Tensor(new_state).unsqueeze(0)).numpy()))
        current_state = new_state
        parent_idx = leaf_id
        ttt2 = time.time()
        for key in steer_time_dict.keys():
            if not key in t_dict['steertime_division']:
                t_dict['steertime_division'][key] = steer_time_dict[key]
            else:
                t_dict['steertime_division'][key] += steer_time_dict[key]
        ttt3 = time.time()
        t_dict['steertime_division']['total_steer'] += ttt1-ttt0
        t_dict['steertime_division']['insert'] += ttt2-ttt1
        t_dict['steertime_division']['update_dict'] += ttt3-ttt2
        if not no_collision:
            break

    # if not no_collision:
    #     print('warning')
    t2 = time.time()
    t_dict['total_steer'] = t2 - t1
    done = bool(dynamics_model.goal_mask(torch.Tensor(new_state).unsqueeze(0)).numpy())
    t_dict['total_explore']=time.time()-t0
    return new_state, sample_state, search_tree.non_terminal_idxes[nearest_idx], no_collision, done, t_dict, edge_states


@torch.no_grad()
def steer(u, dynamics_model, new_state, nearest, RRT_step=10, device='cpu'):
    time_dict = {'complete_sample': 0, 'cl_dynamics': 0, 'misc': 0, 'collision_checking': 0}
    t0 = time.time()
    no_collision = True
    x_list = [nearest]
    controller_update_freq = dynamics_model.controller_dt // dynamics_model.dt

    dynamics_model.set_intermediate_goals(new_state)
    x_current = dynamics_model.complete_sample_with_observations(torch.tensor(nearest, device=device).unsqueeze(0), 1)
    time_dict['complete_sample'] += (time.time() - t0)
    for tstep in range(RRT_step):
        if tstep % controller_update_freq == 0:
            tt0 = time.time()
            u_current = u(x_current)
            if isinstance(u_current, tuple):
                u_current, u_time_dict = u_current
            else:
                u_time_dict = {"u": time.time() - tt0}
            for key in u_time_dict.keys():
                if not key in time_dict:
                    time_dict[key] = u_time_dict[key]
                else:
                    time_dict[key] += u_time_dict[key]
        # t1 = time.time()
        if (tstep + 1) % controller_update_freq == 0:
            x_current, tt_list = dynamics_model.closed_loop_dynamics(x_current, u_current, update_observation=True, return_time=True)
        else:
            x_current, tt_list = dynamics_model.closed_loop_dynamics(x_current, u_current, update_observation=False, return_time=True)
        # time_dict['cl_dynamics'] += (time.time() - t1)
        # print(x_current.data, u_current.data)
        time_dict['cl_dynamics'] += tt_list[0]
        time_dict['complete_sample'] += tt_list[1]
        tt1 = time.time()
        if dynamics_model.unsafe_mask(x_current):
            no_collision = False
            break

    #     x_list.append(x_current.cpu().squeeze().numpy())
    #     # stuck
    #     if tstep > 10 and np.linalg.norm(x_list[-1] - x_list[-10]) < 1e-1:
    #         break
    # return x_current.cpu().squeeze().numpy()[:dynamics_model.q_dims], no_collision, time_dict, x_list
        tt2 = time.time()
        x_list.append(x_current.cpu().squeeze().numpy()[:dynamics_model.q_dims])
        # stuck
        if tstep > 10 and np.linalg.norm(x_list[-1] - x_list[-10]) < 1e-1: #1e-2 * dynamics_model.n_dims:
            # u = dynamics_model.u_nominal
            # # print('stuck')
            break
        time_dict['collision_checking'] += (tt2 - tt1)
        time_dict['misc'] += (time.time() - tt2)
    return x_list[-1], no_collision, time_dict, x_list


def edge_checking(state, new_state, dynamics_model, eps):
    assert state.size == new_state.size

    if not dynamics_model.safe_mask(torch.Tensor(new_state).unsqueeze(0)):
        return False

    disp = new_state - state

    d = np.linalg.norm(state - new_state)
    K = int(d / eps)
    for k in range(0, K):
        c = state + k * 1. / K * disp
        if not dynamics_model.safe_mask(torch.Tensor(c).unsqueeze(0)):
            return False
    return True
